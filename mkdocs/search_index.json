{
    "docs": [
        {
            "location": "/", 
            "text": "Functional Reactive with Core Java\n\n\n\n\n... we just started with this ... ;-)\n\n\nif you can not wait..  check out some code.. \n\n\nFunctional Reactive Lib\n\n\nWorkshop - Functional Reactive", 
            "title": "Home"
        }, 
        {
            "location": "/#functional-reactive-with-core-java", 
            "text": "... we just started with this ... ;-)  if you can not wait..  check out some code..   Functional Reactive Lib  Workshop - Functional Reactive", 
            "title": "Functional Reactive with Core Java"
        }, 
        {
            "location": "/core/", 
            "text": "Java Core Classes\n\n\nHere we are collectiong all the things that we need\nmore often during the examples. All this we are \nmissing in Core Java ;-)\n\n\nPair , Tripel, Quad and Quint\n\n\nFrom time to time we want to have classes like a Tuple or even more.\nHere are some of them up to Quint. Hopefully we could remove them soon\nand replace it with Core JDK Classes.\n\n\npublic class Pair\nT1, T2\n {\n  private T1 t1;\n  private T2 t2;\n\n  public Pair(final T1 t1, final T2 t2) {\n    this.t1 = t1;\n    this.t2 = t2;\n  }\n\n  public T1 getT1() {\n    return t1;\n  }\n\n  public T2 getT2() {\n    return t2;\n  }\n\n  @Override\n  public String toString() {\n    return \nPair{\n +\n        \nt1=\n + t1 +\n        \n, t2=\n + t2 +\n        '}';\n  }\n\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (!(o instanceof Pair)) return false;\n    final Pair\n?, ?\n pair = (Pair\n?, ?\n) o;\n    return Objects.equals(t1, pair.t1) \n\n        Objects.equals(t2, pair.t2);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(t1, t2);\n  }\n}\n\n\n\n\nAll classes are build up like the Pair.", 
            "title": "Core"
        }, 
        {
            "location": "/core/#java-core-classes", 
            "text": "Here we are collectiong all the things that we need\nmore often during the examples. All this we are \nmissing in Core Java ;-)", 
            "title": "Java Core Classes"
        }, 
        {
            "location": "/core/#pair-tripel-quad-and-quint", 
            "text": "From time to time we want to have classes like a Tuple or even more.\nHere are some of them up to Quint. Hopefully we could remove them soon\nand replace it with Core JDK Classes.  public class Pair T1, T2  {\n  private T1 t1;\n  private T2 t2;\n\n  public Pair(final T1 t1, final T2 t2) {\n    this.t1 = t1;\n    this.t2 = t2;\n  }\n\n  public T1 getT1() {\n    return t1;\n  }\n\n  public T2 getT2() {\n    return t2;\n  }\n\n  @Override\n  public String toString() {\n    return  Pair{  +\n         t1=  + t1 +\n         , t2=  + t2 +\n        '}';\n  }\n\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (!(o instanceof Pair)) return false;\n    final Pair ?, ?  pair = (Pair ?, ? ) o;\n    return Objects.equals(t1, pair.t1)  \n        Objects.equals(t2, pair.t2);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(t1, t2);\n  }\n}  All classes are build up like the Pair.", 
            "title": "Pair , Tripel, Quad and Quint"
        }, 
        {
            "location": "/basics/", 
            "text": "Java Core Basics\n\n\nIf you start with the functional way of coding, you will start \nsearching for the best place to define the functions.\nHow to create them and some other practical things.\nHere I will describe the way I would do it.. And what kind of language \nfeatures I am using for this.\n\n\nInterfaces\n\n\nInterfaces are a good point to start with stateless code pieces.\nBut lets start with the Java8 features we got and we could use.\n\n\nInheritance and default implementations\n\n\nSince Java8 we have default implementations. This is good to define \nInterfaces with more than one method, but providing for n-1 methods an\nimplementation. So we got a Functional Interface and we could use now Lambdas with this.\nBut I don\u00b4t want to go too deep into the details. There is a lot of good documentation \navailable on the market. \n\n\npublic static methods\n\n\nHere we could start now with the functional aspects. Ok not with the functional aspects \nitself, but with the way to create instances of functions.\n\n\nLet\u00b4s see why.\nIf we are defining Functions, we have to type them.\n\n\nFunction\nString, String\n func = (str) -\n str + \n-something usefull\n;\n\n\n\n\nNow we could use this, but how we could define Functions with Generics?\nWe start now with the task, how to convert a Enumeration into a Stream, \nor more precise, an Enumeration\n to a Stream\n?\n\n\nFor this we need a Function like the follwing.\n\n\nFunction\nEnumeration\nT\n, Stream\nT\n convert = (T t) -\n ....\n\n\n\n\nBut this you are not able to do. So for this we need a Method that will create an instance of an \nfunction. And for this, we should use static methods in interfaces.\n\n\n  static \nT\n Function\nEnumeration\nT\n, Stream\nT\n enumToStream() {\n    return (e) -\n\n        StreamSupport\n            .stream(Spliterators.spliteratorUnknownSize(new Iterator\nT\n() {\n              public T next() {\n                return e.nextElement();\n              }\n\n              public boolean hasNext() {\n                return e.hasMoreElements();\n              }\n            }, Spliterator.ORDERED), false);\n  }\n\n\n\n\npublic static attributes\n\n\nYes, you could define static attibutes in interfaces. But it is a good advise \nto use them only for things that are not changing. Maybe a const String, \nor a defined NULL-Object for a specific class you have to deal with.\n\n\nJava9 JEP213 - private methods in interfaces\n\n\nHow you could combine old and new\n\n\nIn jab\u00b4a we have different ways to connect to the old Java World.\nHere I want to describe a way, that not so often is used or \nmaybe known by the developers.\n\n\nLet\u00b4s say we have a LegacyService and it is not allowed to change anything. \n(or maybe it is a third party lib and you can not change anything)\n\n\nFrom an instance of this LegacyService you could grap a Methodreference.\n\n\nfinal BiFunction\nString, Integer, String\n myFunction = legacyService::doWork;\n\n\n\n\nOh, what is this? No cast? Yes, no explicit cast.. And LegacyService is \nnot implementing the Interface BiFunction. But....\n\n\nWhat we are using here, is the mechanism \"invoke dynamic\". What must fit, is the \namount and type of params and return type. If this match, you could do it. \nAnd it is not limited to the Functional Interfaces from the JDK. So if you have a\nlegacy method with four params, create a QuadFunction. And have in mind, \nreturn type could be Void.\n\n\n  public class LegacyService {\n    public String doWork(String str, Integer integer) {\n      return \nlegacy-\n + str + \n - \n + integer;\n    }\n  }\n\n  public static void main(String[] args) {\n    final LegacyService legacyService = new LegacyService();\n    final BiFunction\nString, Integer, String\n myFunction = legacyService::doWork;\n    final Function\nString, String\n function = input -\n \nnextFunction - \n + input;\n    final BiFunction\nString, Integer, String\n andThen = myFunction.andThen(function);\n    String hello = andThen.apply(\nHello\n, 42);\n    System.out.println(\nhello = \n + hello);\n  }\n\n\n\n\nNow we could combine legacy code with new functions.", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#java-core-basics", 
            "text": "If you start with the functional way of coding, you will start \nsearching for the best place to define the functions.\nHow to create them and some other practical things.\nHere I will describe the way I would do it.. And what kind of language \nfeatures I am using for this.", 
            "title": "Java Core Basics"
        }, 
        {
            "location": "/basics/#interfaces", 
            "text": "Interfaces are a good point to start with stateless code pieces.\nBut lets start with the Java8 features we got and we could use.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/basics/#inheritance-and-default-implementations", 
            "text": "Since Java8 we have default implementations. This is good to define \nInterfaces with more than one method, but providing for n-1 methods an\nimplementation. So we got a Functional Interface and we could use now Lambdas with this.\nBut I don\u00b4t want to go too deep into the details. There is a lot of good documentation \navailable on the market.", 
            "title": "Inheritance and default implementations"
        }, 
        {
            "location": "/basics/#public-static-methods", 
            "text": "Here we could start now with the functional aspects. Ok not with the functional aspects \nitself, but with the way to create instances of functions.  Let\u00b4s see why.\nIf we are defining Functions, we have to type them.  Function String, String  func = (str) -  str +  -something usefull ;  Now we could use this, but how we could define Functions with Generics?\nWe start now with the task, how to convert a Enumeration into a Stream, \nor more precise, an Enumeration  to a Stream ?  For this we need a Function like the follwing.  Function Enumeration T , Stream T  convert = (T t) -  ....  But this you are not able to do. So for this we need a Method that will create an instance of an \nfunction. And for this, we should use static methods in interfaces.    static  T  Function Enumeration T , Stream T  enumToStream() {\n    return (e) - \n        StreamSupport\n            .stream(Spliterators.spliteratorUnknownSize(new Iterator T () {\n              public T next() {\n                return e.nextElement();\n              }\n\n              public boolean hasNext() {\n                return e.hasMoreElements();\n              }\n            }, Spliterator.ORDERED), false);\n  }", 
            "title": "public static methods"
        }, 
        {
            "location": "/basics/#public-static-attributes", 
            "text": "Yes, you could define static attibutes in interfaces. But it is a good advise \nto use them only for things that are not changing. Maybe a const String, \nor a defined NULL-Object for a specific class you have to deal with.", 
            "title": "public static attributes"
        }, 
        {
            "location": "/basics/#java9-jep213-private-methods-in-interfaces", 
            "text": "", 
            "title": "Java9 JEP213 - private methods in interfaces"
        }, 
        {
            "location": "/basics/#how-you-could-combine-old-and-new", 
            "text": "In jab\u00b4a we have different ways to connect to the old Java World.\nHere I want to describe a way, that not so often is used or \nmaybe known by the developers.  Let\u00b4s say we have a LegacyService and it is not allowed to change anything. \n(or maybe it is a third party lib and you can not change anything)  From an instance of this LegacyService you could grap a Methodreference.  final BiFunction String, Integer, String  myFunction = legacyService::doWork;  Oh, what is this? No cast? Yes, no explicit cast.. And LegacyService is \nnot implementing the Interface BiFunction. But....  What we are using here, is the mechanism \"invoke dynamic\". What must fit, is the \namount and type of params and return type. If this match, you could do it. \nAnd it is not limited to the Functional Interfaces from the JDK. So if you have a\nlegacy method with four params, create a QuadFunction. And have in mind, \nreturn type could be Void.    public class LegacyService {\n    public String doWork(String str, Integer integer) {\n      return  legacy-  + str +   -   + integer;\n    }\n  }\n\n  public static void main(String[] args) {\n    final LegacyService legacyService = new LegacyService();\n    final BiFunction String, Integer, String  myFunction = legacyService::doWork;\n    final Function String, String  function = input -   nextFunction -   + input;\n    final BiFunction String, Integer, String  andThen = myFunction.andThen(function);\n    String hello = andThen.apply( Hello , 42);\n    System.out.println( hello =   + hello);\n  }  Now we could combine legacy code with new functions.", 
            "title": "How you could combine old and new"
        }, 
        {
            "location": "/functional/", 
            "text": "Functional - Java\n\n\nCore Datastructures\n\n\nCore Transformations\n\n\nif / else to Case", 
            "title": "Functional"
        }, 
        {
            "location": "/functional/#functional-java", 
            "text": "", 
            "title": "Functional - Java"
        }, 
        {
            "location": "/functional/#core-datastructures", 
            "text": "", 
            "title": "Core Datastructures"
        }, 
        {
            "location": "/functional/#core-transformations", 
            "text": "", 
            "title": "Core Transformations"
        }, 
        {
            "location": "/functional/#if-else-to-case", 
            "text": "", 
            "title": "if / else to Case"
        }, 
        {
            "location": "/functional_result/", 
            "text": "Functional - Result, the tuned Optional\n\n\nif we wantb to avoid exceptions and never wantb to give back null, we have to find a solution.\nOne could be the bevaviort to use collections for every result.\nBut this ist def. not what we want. ;-) But if we reduce the collection \nto one element, we are on the road to the Null-Object. \nAfter 7 versions of Java, we got the Optional...\n\n\nOptional\n\n\nThe Optional is a class that is working as a holder for a typed value.\nSo we are able to ask to instance of the Optional if a Value is Present, of \nhow to get an alternative result.\n\n\nHow to use it\n\n\nupdate with Java9\n\n\nWith Java 9 we got a few extensions to this class.\nFor example, something like a flat map or better, \nconvert to a Stream. Even with no value you could \navoid the typical cycle in a stream of filter(isPresent) \nin combination of map(optional.get())\n\n\nResult\n\n\nThe Optional is a good thing so far, and it is part of the JDK.\nBut it is a final class. So, any extensions that you would \nlike to add depending on your project needs.. forget it ;-)\n\n\nSame happened to me so I introduced the class Result. \nResult is a tuned Optional, and it is not defined final.\n\n\nThe result could be saked ifPresent or ifAbsent, so noo need to invert yourself.\n\n\nTo work with the value, there are the methods\n\n\nget() or getOrElse(..) to get the value, or you could define a Consumer and use it\nwith the method ifPresent(consumer)\n\n\nTo create an instance of Result with a value ( even if it is null), there is the method \nofNullable(value). \n\n\nTo Combine a Result with an other value and a function that is dealing with both input values,\nthere is the possiblity to add a BiFunction with the method thenCombine. Or use the method thenCombineAsync\nif yoiu want to go reactive.\n\n\n    Result\nString\n hello = Result.success(\nHello\n);\n    Result\nString\n world = hello.thenCombine(\nWorld\n, (s, s2) -\n Result.success(s + \n - \n + s2));\n    Assert.assertEquals(\nHello - World\n, world.get());", 
            "title": "Memoizing"
        }, 
        {
            "location": "/functional_result/#functional-result-the-tuned-optional", 
            "text": "if we wantb to avoid exceptions and never wantb to give back null, we have to find a solution.\nOne could be the bevaviort to use collections for every result.\nBut this ist def. not what we want. ;-) But if we reduce the collection \nto one element, we are on the road to the Null-Object. \nAfter 7 versions of Java, we got the Optional...", 
            "title": "Functional - Result, the tuned Optional"
        }, 
        {
            "location": "/functional_result/#optional", 
            "text": "The Optional is a class that is working as a holder for a typed value.\nSo we are able to ask to instance of the Optional if a Value is Present, of \nhow to get an alternative result.", 
            "title": "Optional"
        }, 
        {
            "location": "/functional_result/#how-to-use-it", 
            "text": "", 
            "title": "How to use it"
        }, 
        {
            "location": "/functional_result/#update-with-java9", 
            "text": "With Java 9 we got a few extensions to this class.\nFor example, something like a flat map or better, \nconvert to a Stream. Even with no value you could \navoid the typical cycle in a stream of filter(isPresent) \nin combination of map(optional.get())", 
            "title": "update with Java9"
        }, 
        {
            "location": "/functional_result/#result", 
            "text": "The Optional is a good thing so far, and it is part of the JDK.\nBut it is a final class. So, any extensions that you would \nlike to add depending on your project needs.. forget it ;-)  Same happened to me so I introduced the class Result. \nResult is a tuned Optional, and it is not defined final.  The result could be saked ifPresent or ifAbsent, so noo need to invert yourself.  To work with the value, there are the methods  get() or getOrElse(..) to get the value, or you could define a Consumer and use it\nwith the method ifPresent(consumer)  To create an instance of Result with a value ( even if it is null), there is the method \nofNullable(value).   To Combine a Result with an other value and a function that is dealing with both input values,\nthere is the possiblity to add a BiFunction with the method thenCombine. Or use the method thenCombineAsync\nif yoiu want to go reactive.      Result String  hello = Result.success( Hello );\n    Result String  world = hello.thenCombine( World , (s, s2) -  Result.success(s +   -   + s2));\n    Assert.assertEquals( Hello - World , world.get());", 
            "title": "Result"
        }, 
        {
            "location": "/functional_memoizing/", 
            "text": "Functional - Memoizing Functions\n\n\nA Function is memoizing if the function will ever give the same result for the same input.\nAnd here we mean, exactly the same result. Let\u00b4s say the result will be an instance of a car.\nThe result for the same input would give back the instance of the car. Not only an equal one.\n\n\nBut let\u00b4s start with the beginning.\n\n\nAS starting point I will use the following function. \n\n\nFunction\nInteger, Integer\n squareFunction = x -\n {\n    System.out.println(\nIn function\n);\n    return x * x;\n  };\n\n\n\n\nHere I am using the System.out only to show on command line how often this method was invoked. \nI know that this is nothing for production!\n\n\nIf I call this function twice with the same input, the System.out would be on screen two times. So let\u00b4s define \na memoized function.\n\n\nFunction\nInteger, Integer\n memoizationFunction = Memoizer.memoize(squareFunction);\n\n\n\n\nNow I want to have the System.out only on time on screen, expacting that the result was calculated one time.\nWhat we have to do, to get the result?\nThis work is based on the orig article I found \non \nDZONE - Java8 Automatic Memoization\n\n\nThe solution here is based on the method (class Map) introduced with Java8.\nSince Java8 you could provide a Lambda to calculate a value corresponding to a key, if the value is not available.\nThis means, if you request a key/value pair the first time, the lambda will be executed to create the value.\nAt the same time it ist stored in the map. For our solution the ``ConcurrentHashMap``` is used.\n\n\npublic class Memoizer\nT, U\n {\n  private final Map\nT, U\n memoizationCache = new ConcurrentHashMap\n();\n\n  private Function\nT, U\n doMemoize(final Function\nT, U\n function) {\n    return input -\n memoizationCache.computeIfAbsent(input, function);\n  }\n\n  public static \nT, U\n Function\nT, U\n memoize(final Function\nT, U\n function) {\n    return new Memoizer\nT, U\n().doMemoize(function);\n  }\n}\n\n\n\n\nAnd now we have the first version, but only for \nFunction\nT,U\n.\nBut what could we do with a \nBiFunction\nT1,T2, R\n?\n\n\nLet\u00b4s play around with the Function itself. We could transform am \nBiFunction\nT1,T2,R\n \n\n\nBiFunction\nInteger,Integer,Integer\n biFunction = (x,y) -\n x * y;\n\n\n\n\ninto a \nFunction\nT1,Function\nT2,R\n.\n\n\nFunction\nInteger, Function\nInteger, Integer\n biFunction = x -\n y -\n x * y;\n\n\n\n\nWith this we are able to build a memoized function again. This would end up in the first version like the following.\n\n\nFunction\nInteger, Function\nInteger,Integer\n memoizationFunction\n      = Memoizer.memoize(x -\n Memoizer.memoize(y -\n x * y));\n\n\n\n\nSo far so good, but the usage itself is not nice. First is the transformation into the Function of a Function instead of using the \noriginal BiFunction, and the second is the usage of the memoized Function itself.\n\n\n  public static void main(String[] args) {\n    System.out.println(\nmemoizationFunction = \n + memoizationFunction.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + memoizationFunction.apply(2).apply(3));\n  }\n\n\n\n\nNow we could use the orig BiFunction inside the memoized Function.\n\n\nBiFunction\nInteger,Integer,Integer\n mul = (x, y) -\n x*y;\n\nFunction\nInteger, Function\nInteger,Integer\n memoizationFunction\n      = Memoizer.memoize(\n          x -\n Memoizer.memoize(\n              y -\n mul.apply(x,y)));\n\n\n\n\nWith this we could make it a little bit more comfortable and provide a create method.\nThe biggest change here is the introduction of a \nSupplier\nInteger\n.\nSo we changed the BiFunction into \nBiFunction\nInteger, Integer, Supplier\nInteger\n.\nNow we could use the method create with a lambda expression as argument to get a memoized Function.\nBut still the result is \nFunction\nInteger, Function\nInteger, Integer\n\n\n  public static Function\nInteger, Function\nInteger, Integer\n create(\n      BiFunction\nInteger, Integer, Supplier\nInteger\n biFuncSupplier) {\n    return Memoizer.memoize(x -\n Memoizer.memoize(y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = create((x, y) -\n () -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n  }\n\n\n\n\nBut we don\u00b4t want to transform the orig BiFunction. The transformation could be done \nin a generic way. \n\n\n  public static Function\nInteger, Function\nInteger, Integer\n transform(\n      final BiFunction\nInteger, Integer, Integer\n biFunc) {\n    return create((x, y) -\n () -\n biFunc.apply(x, y));\n  }\n\n  private static Function\nInteger, Function\nInteger, Integer\n create(\n      BiFunction\nInteger, Integer, Supplier\nInteger\n biFuncSupplier) {\n    return Memoizer.memoize(\n        x -\n Memoizer.memoize(\n            y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = transform((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n  }\n\n\n\n\nOr if you want to remove the types with generics....\n\n\n  public static \nT1, T2, R\n Function\nT1, Function\nT2, R\n transform(\n      final BiFunction\nT1, T2, R\n biFunc) {\n    return create((x, y) -\n () -\n biFunc.apply(x, y));\n  }\n\n  private static \nT1, T2, R\n Function\nT1, Function\nT2, R\n create(\n      BiFunction\nT1, T2, Supplier\nR\n biFuncSupplier) {\n    return Memoizer.memoize(x -\n Memoizer.memoize(y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = transform((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n  }\n\n\n\n\nNow we are able to transform the \nBiFunction\nT1, T2, R\n, but the result is a \nFunction\nT1, Function\nT2, R\n\nThis is not nice to use, so we want to transform it back to a \nBiFunction\nT1, T2, R\n.\n\n\n  public static \nT1, T2, R\n BiFunction\nT1, T2, R\n prepare(\n      final Function\nT1, Function\nT2, R\n transformed) {\n    return (x, y) -\n transformed.apply(x).apply(y);\n  }\n\n\n\n\nFinally we are able to transform in both directions.\n\nBiFunction\nT1, T2, R\n -\n \nFunction\nT1, Function\nT2, R\n -\n \nBiFunction\nT1, T2, R\n.\n\n\nAll together is now \n\n\npublic static \nT1, T2, R\n BiFunction\nT1, T2, R\n prepare(\n      final Function\nT1, Function\nT2, R\n transformed) {\n    return (x, y) -\n transformed.apply(x).apply(y);\n  }\n\n  public static \nT1, T2, R\n Function\nT1, Function\nT2, R\n transform(\n      final BiFunction\nT1, T2, R\n biFunc) {\n    return create((x, y) -\n () -\n biFunc.apply(x, y));\n  }\n\n  private static \nT1, T2, R\n Function\nT1, Function\nT2, R\n create(\n      BiFunction\nT1, T2, Supplier\nR\n biFuncSupplier) {\n    return Memoizer.memoize(\n        x -\n Memoizer.memoize(\n            y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = transform((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n\n    System.out.println(\nmemoizationFunction = \n + prepare(function).apply(2,3));\n    System.out.println(\nmemoizationFunction = \n + prepare(function).apply(2,3));\n  }\n\n\n\n\nAfter we found out how to transform in small steps, we are able to merge all together in a smaller \nmethod. The result looks like the following.\n\n\n  public static \nT1, T2, R\n BiFunction\nT1, T2, R\n memoize(final BiFunction\nT1, T2, R\n biFunc) {\n    final BiFunction\nT1, T2, Supplier\nR\n biFuncSupplier = (x, y) -\n () -\n biFunc.apply(x, y);\n    final Function\nT1, Function\nT2, R\n transformed \n           = Memoizer.memoize(\n               x -\n Memoizer.memoize(\n                   y -\n biFuncSupplier.apply(x, y).get()));\n    return (x, y) -\n transformed.apply(x).apply(y);\n  }\n\n  public static void main(String[] args) {\n    final BiFunction\nInteger, Integer, Integer\n function = memoize((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3));\n  }\n\n\n\n\nThe step now to a NFunction is not so far..  let\u00b4s see how we could do it with \nthree params. The first thing we have to create is a \nTriFunction\nT1,T2,T3,R\n, because it is not part of the JDK until now.\n\n\n  @FunctionalInterface\n  public interface TriFunction\nT1, T2,T3, R\n {\n    R apply(T1 t1, T2 t2, T3 t3);\n\n    default \nV\n TriFunction\nT1, T2,T3, V\n andThen(Function\n? super R, ? extends V\n after) {\n      Objects.requireNonNull(after);\n      return (T1 t1, T2 t2, T3 t3) -\n after.apply(apply(t1, t2, t3));\n    }\n  }\n\n\n\n\nAnd finally the memoize looks like....\n\n\n  public static \nT1, T2,T3, R\n TriFunction\nT1, T2,T3, R\n memoize(final TriFunction\nT1, T2,T3, R\n threeFunc) {\n    final TriFunction\nT1, T2,T3, Supplier\nR\n threeFuncSupplier \n             = (x, y, z) -\n () -\n threeFunc.apply(x, y,z);\n    final Function\nT1, Function\nT2, Function\nT3, R\n transformed\n        = Memoizer.memoize(\n            x -\n Memoizer.memoize(\n                y -\n Memoizer.memoize(\n                    z -\n threeFuncSupplier.apply(x, y,z).get())));\n    return (x, y, z) -\n transformed.apply(x).apply(y).apply(z);\n  }\n\n  public static void main(String[] args) {\n    final TriFunction\nInteger, Integer, Integer, Integer\n function = memoize((x, y, z) -\n {\n      System.out.println(\nexecute x/y/z = \n + x + \n / \n + y + \n / \n + z);\n      return x * y * z;\n    });\n\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3,-1));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3,-1));\n  }\n\n\n\n\nSo, now we have everything for a NFunction together ;-)", 
            "title": "Memoizing"
        }, 
        {
            "location": "/functional_memoizing/#functional-memoizing-functions", 
            "text": "A Function is memoizing if the function will ever give the same result for the same input.\nAnd here we mean, exactly the same result. Let\u00b4s say the result will be an instance of a car.\nThe result for the same input would give back the instance of the car. Not only an equal one.  But let\u00b4s start with the beginning.  AS starting point I will use the following function.   Function Integer, Integer  squareFunction = x -  {\n    System.out.println( In function );\n    return x * x;\n  };  Here I am using the System.out only to show on command line how often this method was invoked. \nI know that this is nothing for production!  If I call this function twice with the same input, the System.out would be on screen two times. So let\u00b4s define \na memoized function.  Function Integer, Integer  memoizationFunction = Memoizer.memoize(squareFunction);  Now I want to have the System.out only on time on screen, expacting that the result was calculated one time.\nWhat we have to do, to get the result?\nThis work is based on the orig article I found \non  DZONE - Java8 Automatic Memoization  The solution here is based on the method (class Map) introduced with Java8.\nSince Java8 you could provide a Lambda to calculate a value corresponding to a key, if the value is not available.\nThis means, if you request a key/value pair the first time, the lambda will be executed to create the value.\nAt the same time it ist stored in the map. For our solution the ``ConcurrentHashMap``` is used.  public class Memoizer T, U  {\n  private final Map T, U  memoizationCache = new ConcurrentHashMap ();\n\n  private Function T, U  doMemoize(final Function T, U  function) {\n    return input -  memoizationCache.computeIfAbsent(input, function);\n  }\n\n  public static  T, U  Function T, U  memoize(final Function T, U  function) {\n    return new Memoizer T, U ().doMemoize(function);\n  }\n}  And now we have the first version, but only for  Function T,U .\nBut what could we do with a  BiFunction T1,T2, R ?  Let\u00b4s play around with the Function itself. We could transform am  BiFunction T1,T2,R    BiFunction Integer,Integer,Integer  biFunction = (x,y) -  x * y;  into a  Function T1,Function T2,R .  Function Integer, Function Integer, Integer  biFunction = x -  y -  x * y;  With this we are able to build a memoized function again. This would end up in the first version like the following.  Function Integer, Function Integer,Integer  memoizationFunction\n      = Memoizer.memoize(x -  Memoizer.memoize(y -  x * y));  So far so good, but the usage itself is not nice. First is the transformation into the Function of a Function instead of using the \noriginal BiFunction, and the second is the usage of the memoized Function itself.    public static void main(String[] args) {\n    System.out.println( memoizationFunction =   + memoizationFunction.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + memoizationFunction.apply(2).apply(3));\n  }  Now we could use the orig BiFunction inside the memoized Function.  BiFunction Integer,Integer,Integer  mul = (x, y) -  x*y;\n\nFunction Integer, Function Integer,Integer  memoizationFunction\n      = Memoizer.memoize(\n          x -  Memoizer.memoize(\n              y -  mul.apply(x,y)));  With this we could make it a little bit more comfortable and provide a create method.\nThe biggest change here is the introduction of a  Supplier Integer .\nSo we changed the BiFunction into  BiFunction Integer, Integer, Supplier Integer .\nNow we could use the method create with a lambda expression as argument to get a memoized Function.\nBut still the result is  Function Integer, Function Integer, Integer    public static Function Integer, Function Integer, Integer  create(\n      BiFunction Integer, Integer, Supplier Integer  biFuncSupplier) {\n    return Memoizer.memoize(x -  Memoizer.memoize(y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = create((x, y) -  () -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n  }  But we don\u00b4t want to transform the orig BiFunction. The transformation could be done \nin a generic way.     public static Function Integer, Function Integer, Integer  transform(\n      final BiFunction Integer, Integer, Integer  biFunc) {\n    return create((x, y) -  () -  biFunc.apply(x, y));\n  }\n\n  private static Function Integer, Function Integer, Integer  create(\n      BiFunction Integer, Integer, Supplier Integer  biFuncSupplier) {\n    return Memoizer.memoize(\n        x -  Memoizer.memoize(\n            y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = transform((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n  }  Or if you want to remove the types with generics....    public static  T1, T2, R  Function T1, Function T2, R  transform(\n      final BiFunction T1, T2, R  biFunc) {\n    return create((x, y) -  () -  biFunc.apply(x, y));\n  }\n\n  private static  T1, T2, R  Function T1, Function T2, R  create(\n      BiFunction T1, T2, Supplier R  biFuncSupplier) {\n    return Memoizer.memoize(x -  Memoizer.memoize(y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = transform((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n  }  Now we are able to transform the  BiFunction T1, T2, R , but the result is a  Function T1, Function T2, R \nThis is not nice to use, so we want to transform it back to a  BiFunction T1, T2, R .    public static  T1, T2, R  BiFunction T1, T2, R  prepare(\n      final Function T1, Function T2, R  transformed) {\n    return (x, y) -  transformed.apply(x).apply(y);\n  }  Finally we are able to transform in both directions. BiFunction T1, T2, R  -   Function T1, Function T2, R  -   BiFunction T1, T2, R .  All together is now   public static  T1, T2, R  BiFunction T1, T2, R  prepare(\n      final Function T1, Function T2, R  transformed) {\n    return (x, y) -  transformed.apply(x).apply(y);\n  }\n\n  public static  T1, T2, R  Function T1, Function T2, R  transform(\n      final BiFunction T1, T2, R  biFunc) {\n    return create((x, y) -  () -  biFunc.apply(x, y));\n  }\n\n  private static  T1, T2, R  Function T1, Function T2, R  create(\n      BiFunction T1, T2, Supplier R  biFuncSupplier) {\n    return Memoizer.memoize(\n        x -  Memoizer.memoize(\n            y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = transform((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n\n    System.out.println( memoizationFunction =   + prepare(function).apply(2,3));\n    System.out.println( memoizationFunction =   + prepare(function).apply(2,3));\n  }  After we found out how to transform in small steps, we are able to merge all together in a smaller \nmethod. The result looks like the following.    public static  T1, T2, R  BiFunction T1, T2, R  memoize(final BiFunction T1, T2, R  biFunc) {\n    final BiFunction T1, T2, Supplier R  biFuncSupplier = (x, y) -  () -  biFunc.apply(x, y);\n    final Function T1, Function T2, R  transformed \n           = Memoizer.memoize(\n               x -  Memoizer.memoize(\n                   y -  biFuncSupplier.apply(x, y).get()));\n    return (x, y) -  transformed.apply(x).apply(y);\n  }\n\n  public static void main(String[] args) {\n    final BiFunction Integer, Integer, Integer  function = memoize((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n\n    System.out.println( memoizationFunction =   + function.apply(2,3));\n    System.out.println( memoizationFunction =   + function.apply(2,3));\n  }  The step now to a NFunction is not so far..  let\u00b4s see how we could do it with \nthree params. The first thing we have to create is a  TriFunction T1,T2,T3,R , because it is not part of the JDK until now.    @FunctionalInterface\n  public interface TriFunction T1, T2,T3, R  {\n    R apply(T1 t1, T2 t2, T3 t3);\n\n    default  V  TriFunction T1, T2,T3, V  andThen(Function ? super R, ? extends V  after) {\n      Objects.requireNonNull(after);\n      return (T1 t1, T2 t2, T3 t3) -  after.apply(apply(t1, t2, t3));\n    }\n  }  And finally the memoize looks like....    public static  T1, T2,T3, R  TriFunction T1, T2,T3, R  memoize(final TriFunction T1, T2,T3, R  threeFunc) {\n    final TriFunction T1, T2,T3, Supplier R  threeFuncSupplier \n             = (x, y, z) -  () -  threeFunc.apply(x, y,z);\n    final Function T1, Function T2, Function T3, R  transformed\n        = Memoizer.memoize(\n            x -  Memoizer.memoize(\n                y -  Memoizer.memoize(\n                    z -  threeFuncSupplier.apply(x, y,z).get())));\n    return (x, y, z) -  transformed.apply(x).apply(y).apply(z);\n  }\n\n  public static void main(String[] args) {\n    final TriFunction Integer, Integer, Integer, Integer  function = memoize((x, y, z) -  {\n      System.out.println( execute x/y/z =   + x +   /   + y +   /   + z);\n      return x * y * z;\n    });\n\n    System.out.println( memoizationFunction =   + function.apply(2,3,-1));\n    System.out.println( memoizationFunction =   + function.apply(2,3,-1));\n  }  So, now we have everything for a NFunction together ;-)", 
            "title": "Functional - Memoizing Functions"
        }, 
        {
            "location": "/pattern/", 
            "text": "Java Pattern - functional style", 
            "title": "Pattern"
        }, 
        {
            "location": "/pattern/#java-pattern-functional-style", 
            "text": "", 
            "title": "Java Pattern - functional style"
        }, 
        {
            "location": "/reactive/", 
            "text": "Reactive Core Java", 
            "title": "Reactive"
        }, 
        {
            "location": "/reactive/#reactive-core-java", 
            "text": "", 
            "title": "Reactive Core Java"
        }
    ]
}