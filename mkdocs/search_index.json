{
    "docs": [
        {
            "location": "/", 
            "text": "Functional Reactive with Core Java\n\n\n\n\n... we just started with this ... ;-)\n\n\nif you can not wait..  check out some code.. \n\n\nWorkshop - Functional Reactive", 
            "title": "Home"
        }, 
        {
            "location": "/#functional-reactive-with-core-java", 
            "text": "... we just started with this ... ;-)  if you can not wait..  check out some code..   Workshop - Functional Reactive", 
            "title": "Functional Reactive with Core Java"
        }, 
        {
            "location": "/core/", 
            "text": "Java Core Classes\n\n\nHere we are collectiong all the things that we need\nmore often during the examples. All this we are \nmissing in Core Java ;-)\n\n\nTupel , Tripel, Quad and Quint\n\n\nFrom time to time we want to have classes like a Tuple or even more.\nHere are some of them up to Quint. Hopefully we could remove them soon\nand replace it with Core JDK Classes.\n\n\npublic class Tuple\nT1, T2\n {\n  private T1 t1;\n  private T2 t2;\n\n  public Tuple(final T1 t1, final T2 t2) {\n    this.t1 = t1;\n    this.t2 = t2;\n  }\n\n  public T1 getT1() {\n    return t1;\n  }\n\n  public T2 getT2() {\n    return t2;\n  }\n\n  @Override\n  public String toString() {\n    return \nTuple{\n +\n        \nt1=\n + t1 +\n        \n, t2=\n + t2 +\n        '}';\n  }\n\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (!(o instanceof Tuple)) return false;\n    final Tuple\n?, ?\n tuple = (Tuple\n?, ?\n) o;\n    return Objects.equals(t1, tuple.t1) \n\n        Objects.equals(t2, tuple.t2);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(t1, t2);\n  }\n}\n\n\n\n\nAll classes are build up like the Tuple. \nThe sourcecode you could find on GitHub \nFunctional-Reactive-Workshop - Core", 
            "title": "Core"
        }, 
        {
            "location": "/core/#java-core-classes", 
            "text": "Here we are collectiong all the things that we need\nmore often during the examples. All this we are \nmissing in Core Java ;-)", 
            "title": "Java Core Classes"
        }, 
        {
            "location": "/core/#tupel-tripel-quad-and-quint", 
            "text": "From time to time we want to have classes like a Tuple or even more.\nHere are some of them up to Quint. Hopefully we could remove them soon\nand replace it with Core JDK Classes.  public class Tuple T1, T2  {\n  private T1 t1;\n  private T2 t2;\n\n  public Tuple(final T1 t1, final T2 t2) {\n    this.t1 = t1;\n    this.t2 = t2;\n  }\n\n  public T1 getT1() {\n    return t1;\n  }\n\n  public T2 getT2() {\n    return t2;\n  }\n\n  @Override\n  public String toString() {\n    return  Tuple{  +\n         t1=  + t1 +\n         , t2=  + t2 +\n        '}';\n  }\n\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (!(o instanceof Tuple)) return false;\n    final Tuple ?, ?  tuple = (Tuple ?, ? ) o;\n    return Objects.equals(t1, tuple.t1)  \n        Objects.equals(t2, tuple.t2);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(t1, t2);\n  }\n}  All classes are build up like the Tuple. \nThe sourcecode you could find on GitHub  Functional-Reactive-Workshop - Core", 
            "title": "Tupel , Tripel, Quad and Quint"
        }, 
        {
            "location": "/basics/", 
            "text": "Java Core Basics\n\n\nInterfaces\n\n\nInheritance and default implementations\n\n\npublic static methods\n\n\npublic static attributes\n\n\nJava9 JEP213 - private methods in interfaces\n\n\nDifference between class and Lambda\n\n\nOptional\n\n\nHow to use it\n\n\nupdate with Java9", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#java-core-basics", 
            "text": "", 
            "title": "Java Core Basics"
        }, 
        {
            "location": "/basics/#interfaces", 
            "text": "", 
            "title": "Interfaces"
        }, 
        {
            "location": "/basics/#inheritance-and-default-implementations", 
            "text": "", 
            "title": "Inheritance and default implementations"
        }, 
        {
            "location": "/basics/#public-static-methods", 
            "text": "", 
            "title": "public static methods"
        }, 
        {
            "location": "/basics/#public-static-attributes", 
            "text": "", 
            "title": "public static attributes"
        }, 
        {
            "location": "/basics/#java9-jep213-private-methods-in-interfaces", 
            "text": "", 
            "title": "Java9 JEP213 - private methods in interfaces"
        }, 
        {
            "location": "/basics/#difference-between-class-and-lambda", 
            "text": "", 
            "title": "Difference between class and Lambda"
        }, 
        {
            "location": "/basics/#optional", 
            "text": "", 
            "title": "Optional"
        }, 
        {
            "location": "/basics/#how-to-use-it", 
            "text": "", 
            "title": "How to use it"
        }, 
        {
            "location": "/basics/#update-with-java9", 
            "text": "", 
            "title": "update with Java9"
        }, 
        {
            "location": "/functional/", 
            "text": "Functional - Java\n\n\nMemoizing Functions\n\n\nA Function is memoizing if the function will ever give the same result for the same input.\nAnd here we mean, exactly the same result. Let\u00b4s say the result will be an instance of a car.\nThe result for the same input would give back the instance of the car. Not only an equal one.\n\n\nBut let\u00b4s start with the beginning.\n\n\nAS starting point I will use the following function. \n\n\nFunction\nInteger, Integer\n squareFunction = x -\n {\n    System.out.println(\nIn function\n);\n    return x * x;\n  };\n\n\n\n\nHere I am using the System.out only to show on command line how often this method was invoked. \nI know that this is nothing for production!\n\n\nIf I call this function twice with the same input, the System.out would be on screen two times. So let\u00b4s define \na memoized function.\n\n\nFunction\nInteger, Integer\n memoizationFunction = Memoizer.memoize(squareFunction);\n\n\n\n\nNow I want to have the System.out only on time on screen, expacting that the result was calculated one time.\nWhat we have to do, to get the result?\nThis work is based on the orig article I found \non \nDZONE - Java8 Automatic Memoization\n\n\nThe solution here is based on the method (class Map) introduced with Java8.\nSince Java8 you could provide a Lambda to calculate a value corresponding to a key, if the value is not available.\nThis means, if you request a key/value pair the first time, the lambda will be executed to create the value.\nAt the same time it ist stored in the map. For our solution the ``ConcurrentHashMap``` is used.\n\n\npublic class Memoizer\nT, U\n {\n  private final Map\nT, U\n memoizationCache = new ConcurrentHashMap\n();\n\n  private Function\nT, U\n doMemoize(final Function\nT, U\n function) {\n    return input -\n memoizationCache.computeIfAbsent(input, function);\n  }\n\n  public static \nT, U\n Function\nT, U\n memoize(final Function\nT, U\n function) {\n    return new Memoizer\nT, U\n().doMemoize(function);\n  }\n}\n\n\n\n\nAnd now we have the first version, but only for \nFunction\nT,U\n.\nBut what could we do with a \nBiFunction\nT1,T2, R\n?\n\n\nLet\u00b4s play around with the Function itself. We could transform am \nBiFunction\nT1,T2,R\n \n\n\nBiFunction\nInteger,Integer,Integer\n biFunction = (x,y) -\n x * y;\n\n\n\n\ninto a \nFunction\nT1,Function\nT2,R\n.\n\n\nFunction\nInteger, Function\nInteger, Integer\n biFunction = x -\n y -\n x * y;\n\n\n\n\nWith this we are able to build a memoized function again. This would end up in the first version like the following.\n\n\nFunction\nInteger, Function\nInteger,Integer\n memoizationFunction\n      = Memoizer.memoize(x -\n Memoizer.memoize(y -\n x * y));\n\n\n\n\nSo far so good, but the usage itself is not nice. First is the transformation into the Function of a Function instead of using the \noriginal BiFunction, and the second is the usage of the memoized Function itself.\n\n\n  public static void main(String[] args) {\n    System.out.println(\nmemoizationFunction = \n + memoizationFunction.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + memoizationFunction.apply(2).apply(3));\n  }\n\n\n\n\nNow we could use the orig BiFunction inside the memoized Function.\n\n\nBiFunction\nInteger,Integer,Integer\n mul = (x, y) -\n x*y;\n\nFunction\nInteger, Function\nInteger,Integer\n memoizationFunction\n      = Memoizer.memoize(\n          x -\n Memoizer.memoize(\n              y -\n mul.apply(x,y)));\n\n\n\n\nWith this we could make it a little bit more comfortable and provide a create method.\nThe biggest change here is the introduction of a \nSupplier\nInteger\n.\nSo we changed the BiFunction into \nBiFunction\nInteger, Integer, Supplier\nInteger\n.\nNow we could use the method create with a lambda expression as argument to get a memoized Function.\nBut still the result is \nFunction\nInteger, Function\nInteger, Integer\n\n\n  public static Function\nInteger, Function\nInteger, Integer\n create(\n      BiFunction\nInteger, Integer, Supplier\nInteger\n biFuncSupplier) {\n    return Memoizer.memoize(x -\n Memoizer.memoize(y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = create((x, y) -\n () -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n  }\n\n\n\n\nBut we don\u00b4t want to transform the orig BiFunction. The transformation could be done \nin a generic way. \n\n\n  public static Function\nInteger, Function\nInteger, Integer\n transform(\n      final BiFunction\nInteger, Integer, Integer\n biFunc) {\n    return create((x, y) -\n () -\n biFunc.apply(x, y));\n  }\n\n  private static Function\nInteger, Function\nInteger, Integer\n create(\n      BiFunction\nInteger, Integer, Supplier\nInteger\n biFuncSupplier) {\n    return Memoizer.memoize(\n        x -\n Memoizer.memoize(\n            y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = transform((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n  }\n\n\n\n\nOr if you want to remove the types with generics....\n\n\n  public static \nT1, T2, R\n Function\nT1, Function\nT2, R\n transform(\n      final BiFunction\nT1, T2, R\n biFunc) {\n    return create((x, y) -\n () -\n biFunc.apply(x, y));\n  }\n\n  private static \nT1, T2, R\n Function\nT1, Function\nT2, R\n create(\n      BiFunction\nT1, T2, Supplier\nR\n biFuncSupplier) {\n    return Memoizer.memoize(x -\n Memoizer.memoize(y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = transform((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2).apply(3));\n  }\n\n\n\n\nNow we are able to transform the \nBiFunction\nT1, T2, R\n, but the result is a \nFunction\nT1, Function\nT2, R\n\nThis is not nice to use, so we want to transform it back to a \nBiFunction\nT1, T2, R\n.\n\n\n  public static \nT1, T2, R\n BiFunction\nT1, T2, R\n prepare(\n      final Function\nT1, Function\nT2, R\n transformed) {\n    return (x, y) -\n transformed.apply(x).apply(y);\n  }\n\n\n\n\nFinally we are able to transform in both directions.\n\nBiFunction\nT1, T2, R\n -\n \nFunction\nT1, Function\nT2, R\n -\n \nBiFunction\nT1, T2, R\n.\n\n\nAll together is now \n\n\npublic static \nT1, T2, R\n BiFunction\nT1, T2, R\n prepare(\n      final Function\nT1, Function\nT2, R\n transformed) {\n    return (x, y) -\n transformed.apply(x).apply(y);\n  }\n\n  public static \nT1, T2, R\n Function\nT1, Function\nT2, R\n transform(\n      final BiFunction\nT1, T2, R\n biFunc) {\n    return create((x, y) -\n () -\n biFunc.apply(x, y));\n  }\n\n  private static \nT1, T2, R\n Function\nT1, Function\nT2, R\n create(\n      BiFunction\nT1, T2, Supplier\nR\n biFuncSupplier) {\n    return Memoizer.memoize(\n        x -\n Memoizer.memoize(\n            y -\n biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function\nInteger, Function\nInteger, Integer\n function = transform((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n\n    System.out.println(\nmemoizationFunction = \n + prepare(function).apply(2,3));\n    System.out.println(\nmemoizationFunction = \n + prepare(function).apply(2,3));\n  }\n\n\n\n\nAfter we found out how to transform in small steps, we are able to merge all together in a smaller \nmethod. The result looks like the following.\n\n\n  public static \nT1, T2, R\n BiFunction\nT1, T2, R\n memoize(final BiFunction\nT1, T2, R\n biFunc) {\n    final BiFunction\nT1, T2, Supplier\nR\n biFuncSupplier = (x, y) -\n () -\n biFunc.apply(x, y);\n    final Function\nT1, Function\nT2, R\n transformed \n           = Memoizer.memoize(\n               x -\n Memoizer.memoize(\n                   y -\n biFuncSupplier.apply(x, y).get()));\n    return (x, y) -\n transformed.apply(x).apply(y);\n  }\n\n  public static void main(String[] args) {\n    final BiFunction\nInteger, Integer, Integer\n function = memoize((x, y) -\n {\n      System.out.println(\nexecute x/y = \n + x + \n / \n + y);\n      return x * y;\n    });\n\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3));\n  }\n\n\n\n\nThe step now to a NFunction is not so far..  let\u00b4s see how we could do it with \nthree params. The first thing we have to create is a \nTriFunction\nT1,T2,T3,R\n, because it is not part of the JDK until now.\n\n\n  @FunctionalInterface\n  public interface TriFunction\nT1, T2,T3, R\n {\n    R apply(T1 t1, T2 t2, T3 t3);\n\n    default \nV\n TriFunction\nT1, T2,T3, V\n andThen(Function\n? super R, ? extends V\n after) {\n      Objects.requireNonNull(after);\n      return (T1 t1, T2 t2, T3 t3) -\n after.apply(apply(t1, t2, t3));\n    }\n  }\n\n\n\n\nAnd finally the memoize looks like....\n\n\n  public static \nT1, T2,T3, R\n TriFunction\nT1, T2,T3, R\n memoize(final TriFunction\nT1, T2,T3, R\n threeFunc) {\n    final TriFunction\nT1, T2,T3, Supplier\nR\n threeFuncSupplier \n             = (x, y, z) -\n () -\n threeFunc.apply(x, y,z);\n    final Function\nT1, Function\nT2, Function\nT3, R\n transformed\n        = Memoizer.memoize(\n            x -\n Memoizer.memoize(\n                y -\n Memoizer.memoize(\n                    z -\n threeFuncSupplier.apply(x, y,z).get())));\n    return (x, y, z) -\n transformed.apply(x).apply(y).apply(z);\n  }\n\n  public static void main(String[] args) {\n    final TriFunction\nInteger, Integer, Integer, Integer\n function = memoize((x, y, z) -\n {\n      System.out.println(\nexecute x/y/z = \n + x + \n / \n + y + \n / \n + z);\n      return x * y * z;\n    });\n\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3,-1));\n    System.out.println(\nmemoizationFunction = \n + function.apply(2,3,-1));\n  }\n\n\n\n\nSo, now we have everything for a NFunction together ;-)", 
            "title": "Functional"
        }, 
        {
            "location": "/functional/#functional-java", 
            "text": "", 
            "title": "Functional - Java"
        }, 
        {
            "location": "/functional/#memoizing-functions", 
            "text": "A Function is memoizing if the function will ever give the same result for the same input.\nAnd here we mean, exactly the same result. Let\u00b4s say the result will be an instance of a car.\nThe result for the same input would give back the instance of the car. Not only an equal one.  But let\u00b4s start with the beginning.  AS starting point I will use the following function.   Function Integer, Integer  squareFunction = x -  {\n    System.out.println( In function );\n    return x * x;\n  };  Here I am using the System.out only to show on command line how often this method was invoked. \nI know that this is nothing for production!  If I call this function twice with the same input, the System.out would be on screen two times. So let\u00b4s define \na memoized function.  Function Integer, Integer  memoizationFunction = Memoizer.memoize(squareFunction);  Now I want to have the System.out only on time on screen, expacting that the result was calculated one time.\nWhat we have to do, to get the result?\nThis work is based on the orig article I found \non  DZONE - Java8 Automatic Memoization  The solution here is based on the method (class Map) introduced with Java8.\nSince Java8 you could provide a Lambda to calculate a value corresponding to a key, if the value is not available.\nThis means, if you request a key/value pair the first time, the lambda will be executed to create the value.\nAt the same time it ist stored in the map. For our solution the ``ConcurrentHashMap``` is used.  public class Memoizer T, U  {\n  private final Map T, U  memoizationCache = new ConcurrentHashMap ();\n\n  private Function T, U  doMemoize(final Function T, U  function) {\n    return input -  memoizationCache.computeIfAbsent(input, function);\n  }\n\n  public static  T, U  Function T, U  memoize(final Function T, U  function) {\n    return new Memoizer T, U ().doMemoize(function);\n  }\n}  And now we have the first version, but only for  Function T,U .\nBut what could we do with a  BiFunction T1,T2, R ?  Let\u00b4s play around with the Function itself. We could transform am  BiFunction T1,T2,R    BiFunction Integer,Integer,Integer  biFunction = (x,y) -  x * y;  into a  Function T1,Function T2,R .  Function Integer, Function Integer, Integer  biFunction = x -  y -  x * y;  With this we are able to build a memoized function again. This would end up in the first version like the following.  Function Integer, Function Integer,Integer  memoizationFunction\n      = Memoizer.memoize(x -  Memoizer.memoize(y -  x * y));  So far so good, but the usage itself is not nice. First is the transformation into the Function of a Function instead of using the \noriginal BiFunction, and the second is the usage of the memoized Function itself.    public static void main(String[] args) {\n    System.out.println( memoizationFunction =   + memoizationFunction.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + memoizationFunction.apply(2).apply(3));\n  }  Now we could use the orig BiFunction inside the memoized Function.  BiFunction Integer,Integer,Integer  mul = (x, y) -  x*y;\n\nFunction Integer, Function Integer,Integer  memoizationFunction\n      = Memoizer.memoize(\n          x -  Memoizer.memoize(\n              y -  mul.apply(x,y)));  With this we could make it a little bit more comfortable and provide a create method.\nThe biggest change here is the introduction of a  Supplier Integer .\nSo we changed the BiFunction into  BiFunction Integer, Integer, Supplier Integer .\nNow we could use the method create with a lambda expression as argument to get a memoized Function.\nBut still the result is  Function Integer, Function Integer, Integer    public static Function Integer, Function Integer, Integer  create(\n      BiFunction Integer, Integer, Supplier Integer  biFuncSupplier) {\n    return Memoizer.memoize(x -  Memoizer.memoize(y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = create((x, y) -  () -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n  }  But we don\u00b4t want to transform the orig BiFunction. The transformation could be done \nin a generic way.     public static Function Integer, Function Integer, Integer  transform(\n      final BiFunction Integer, Integer, Integer  biFunc) {\n    return create((x, y) -  () -  biFunc.apply(x, y));\n  }\n\n  private static Function Integer, Function Integer, Integer  create(\n      BiFunction Integer, Integer, Supplier Integer  biFuncSupplier) {\n    return Memoizer.memoize(\n        x -  Memoizer.memoize(\n            y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = transform((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n  }  Or if you want to remove the types with generics....    public static  T1, T2, R  Function T1, Function T2, R  transform(\n      final BiFunction T1, T2, R  biFunc) {\n    return create((x, y) -  () -  biFunc.apply(x, y));\n  }\n\n  private static  T1, T2, R  Function T1, Function T2, R  create(\n      BiFunction T1, T2, Supplier R  biFuncSupplier) {\n    return Memoizer.memoize(x -  Memoizer.memoize(y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = transform((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n    System.out.println( memoizationFunction =   + function.apply(2).apply(3));\n  }  Now we are able to transform the  BiFunction T1, T2, R , but the result is a  Function T1, Function T2, R \nThis is not nice to use, so we want to transform it back to a  BiFunction T1, T2, R .    public static  T1, T2, R  BiFunction T1, T2, R  prepare(\n      final Function T1, Function T2, R  transformed) {\n    return (x, y) -  transformed.apply(x).apply(y);\n  }  Finally we are able to transform in both directions. BiFunction T1, T2, R  -   Function T1, Function T2, R  -   BiFunction T1, T2, R .  All together is now   public static  T1, T2, R  BiFunction T1, T2, R  prepare(\n      final Function T1, Function T2, R  transformed) {\n    return (x, y) -  transformed.apply(x).apply(y);\n  }\n\n  public static  T1, T2, R  Function T1, Function T2, R  transform(\n      final BiFunction T1, T2, R  biFunc) {\n    return create((x, y) -  () -  biFunc.apply(x, y));\n  }\n\n  private static  T1, T2, R  Function T1, Function T2, R  create(\n      BiFunction T1, T2, Supplier R  biFuncSupplier) {\n    return Memoizer.memoize(\n        x -  Memoizer.memoize(\n            y -  biFuncSupplier.apply(x, y).get()));\n  }\n\n  public static void main(String[] args) {\n    final Function Integer, Function Integer, Integer  function = transform((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n\n    System.out.println( memoizationFunction =   + prepare(function).apply(2,3));\n    System.out.println( memoizationFunction =   + prepare(function).apply(2,3));\n  }  After we found out how to transform in small steps, we are able to merge all together in a smaller \nmethod. The result looks like the following.    public static  T1, T2, R  BiFunction T1, T2, R  memoize(final BiFunction T1, T2, R  biFunc) {\n    final BiFunction T1, T2, Supplier R  biFuncSupplier = (x, y) -  () -  biFunc.apply(x, y);\n    final Function T1, Function T2, R  transformed \n           = Memoizer.memoize(\n               x -  Memoizer.memoize(\n                   y -  biFuncSupplier.apply(x, y).get()));\n    return (x, y) -  transformed.apply(x).apply(y);\n  }\n\n  public static void main(String[] args) {\n    final BiFunction Integer, Integer, Integer  function = memoize((x, y) -  {\n      System.out.println( execute x/y =   + x +   /   + y);\n      return x * y;\n    });\n\n    System.out.println( memoizationFunction =   + function.apply(2,3));\n    System.out.println( memoizationFunction =   + function.apply(2,3));\n  }  The step now to a NFunction is not so far..  let\u00b4s see how we could do it with \nthree params. The first thing we have to create is a  TriFunction T1,T2,T3,R , because it is not part of the JDK until now.    @FunctionalInterface\n  public interface TriFunction T1, T2,T3, R  {\n    R apply(T1 t1, T2 t2, T3 t3);\n\n    default  V  TriFunction T1, T2,T3, V  andThen(Function ? super R, ? extends V  after) {\n      Objects.requireNonNull(after);\n      return (T1 t1, T2 t2, T3 t3) -  after.apply(apply(t1, t2, t3));\n    }\n  }  And finally the memoize looks like....    public static  T1, T2,T3, R  TriFunction T1, T2,T3, R  memoize(final TriFunction T1, T2,T3, R  threeFunc) {\n    final TriFunction T1, T2,T3, Supplier R  threeFuncSupplier \n             = (x, y, z) -  () -  threeFunc.apply(x, y,z);\n    final Function T1, Function T2, Function T3, R  transformed\n        = Memoizer.memoize(\n            x -  Memoizer.memoize(\n                y -  Memoizer.memoize(\n                    z -  threeFuncSupplier.apply(x, y,z).get())));\n    return (x, y, z) -  transformed.apply(x).apply(y).apply(z);\n  }\n\n  public static void main(String[] args) {\n    final TriFunction Integer, Integer, Integer, Integer  function = memoize((x, y, z) -  {\n      System.out.println( execute x/y/z =   + x +   /   + y +   /   + z);\n      return x * y * z;\n    });\n\n    System.out.println( memoizationFunction =   + function.apply(2,3,-1));\n    System.out.println( memoizationFunction =   + function.apply(2,3,-1));\n  }  So, now we have everything for a NFunction together ;-)", 
            "title": "Memoizing Functions"
        }, 
        {
            "location": "/pattern/", 
            "text": "Java Pattern - functional style", 
            "title": "Pattern"
        }, 
        {
            "location": "/pattern/#java-pattern-functional-style", 
            "text": "", 
            "title": "Java Pattern - functional style"
        }, 
        {
            "location": "/reactive/", 
            "text": "Reactive Core Java", 
            "title": "Reactive"
        }, 
        {
            "location": "/reactive/#reactive-core-java", 
            "text": "", 
            "title": "Reactive Core Java"
        }
    ]
}